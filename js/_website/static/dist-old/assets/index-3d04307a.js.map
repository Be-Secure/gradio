{"version":3,"file":"index-3d04307a.js","sources":["../../../client/js/dist/index.js"],"sourcesContent":["function O(e) {\n  if (e.startsWith(\"http\")) {\n    const { protocol: t, host: s } = new URL(e);\n    return s.endsWith(\"hf.space\") ? {\n      ws_protocol: \"wss\",\n      host: s,\n      http_protocol: t\n    } : {\n      ws_protocol: t === \"https:\" ? \"wss\" : \"ws\",\n      http_protocol: t,\n      host: s\n    };\n  }\n  return {\n    ws_protocol: \"wss\",\n    http_protocol: \"https:\",\n    host: e\n  };\n}\nconst T = /^[^\\/]*\\/[^\\/]*$/, A = /.*hf\\.space\\/{0,1}$/;\nasync function M(e) {\n  const t = e.trim();\n  if (T.test(t)) {\n    const s = (await (await fetch(`https://huggingface.co/api/spaces/${t}/host`)).json()).host;\n    return {\n      space_id: e,\n      ...O(s)\n    };\n  }\n  if (A.test(t)) {\n    const { ws_protocol: s, http_protocol: n, host: o } = O(t);\n    return {\n      space_id: o.replace(\".hf.space\", \"\"),\n      ws_protocol: s,\n      http_protocol: n,\n      host: o\n    };\n  }\n  return {\n    space_id: !1,\n    ...O(t)\n  };\n}\nfunction v(e) {\n  let t = {};\n  return e.forEach(({ api_name: s }, n) => {\n    s && (t[s] = n);\n  }), t;\n}\nconst F = /^(?=[^]*\\b[dD]iscussions{0,1}\\b)(?=[^]*\\b[dD]isabled\\b)[^]*$/;\nasync function B(e) {\n  try {\n    const s = (await fetch(\n      `https://huggingface.co/api/spaces/${e}/discussions`,\n      {\n        method: \"HEAD\"\n      }\n    )).headers.get(\"x-error-message\");\n    return !(s && F.test(s));\n  } catch {\n    return !1;\n  }\n}\nconst J = \"This application is too busy. Keep trying!\", D = \"Connection errored out.\";\nasync function z(e, t) {\n  try {\n    var s = await fetch(e, {\n      method: \"POST\",\n      body: JSON.stringify(t),\n      headers: { \"Content-Type\": \"application/json\" }\n    });\n  } catch {\n    return [{ error: D }, 500];\n  }\n  return [await s.json(), s.status];\n}\nasync function Q(e, t) {\n  const s = new FormData();\n  t.forEach((f) => {\n    s.append(\"files\", f);\n  });\n  try {\n    var n = await fetch(`${e}/upload`, {\n      method: \"POST\",\n      body: s\n    });\n  } catch {\n    return { error: D };\n  }\n  return { files: await n.json() };\n}\nasync function V(e, t) {\n  return new Promise(async (s) => {\n    const n = {\n      predict: R,\n      on: W,\n      off: j,\n      cancel: G\n    };\n    if (typeof window > \"u\" || !(\"WebSocket\" in window) || window.WebSocket.CLOSING !== 2) {\n      const r = await import(\"./wrapper-17f133d7.js\");\n      global.WebSocket = r.WebSocket;\n    }\n    const o = {}, { ws_protocol: f, http_protocol: h, host: w, space_id: y } = await M(e), N = Math.random().toString(36).substring(2), C = /* @__PURE__ */ new Map(), P = {};\n    let d, S = {};\n    function I(r) {\n      return d = r, S = v((r == null ? void 0 : r.dependencies) || []), {\n        config: d,\n        ...n\n      };\n    }\n    function W(r, u) {\n      const c = o;\n      let a = c[r] || [];\n      return c[r] = a, a == null || a.push(u), { ...n, config: d };\n    }\n    function j(r, u) {\n      const c = o;\n      let a = c[r] || [];\n      return a = a == null ? void 0 : a.filter((q) => q !== u), c[r] = a, { ...n, config: d };\n    }\n    function G(r, u) {\n      var a;\n      const c = typeof u == \"number\" ? u : S[r];\n      p({\n        type: \"status\",\n        endpoint: r,\n        fn_index: c,\n        status: \"complete\",\n        queue: !1\n      }), (a = C.get(c)) == null || a.close();\n    }\n    function p(r) {\n      let c = o[r.type] || [];\n      c == null || c.forEach((a) => a(r));\n    }\n    async function L(r) {\n      if (t && t(r), r.status === \"running\")\n        try {\n          d = await U(`${h}//${w}`), s(I(d));\n        } catch {\n          t && t({\n            status: \"error\",\n            message: \"Could not load this space.\",\n            load_status: \"error\",\n            detail: \"NOT_FOUND\"\n          });\n        }\n    }\n    try {\n      d = await U(`${h}//${w}`), s(I(d));\n    } catch {\n      y ? $(\n        y,\n        T.test(y) ? \"space_name\" : \"subdomain\",\n        L\n      ) : t && t({\n        status: \"error\",\n        message: \"Could not load this space.\",\n        load_status: \"error\",\n        detail: \"NOT_FOUND\"\n      });\n    }\n    function x(r, u) {\n      return new Promise((c, a) => {\n        const q = r.replace(/^\\//, \"\");\n        let i = typeof u.fn_index == \"number\" ? u.fn_index : S[q];\n        if (K(i, d))\n          p({\n            type: \"status\",\n            endpoint: r,\n            status: \"pending\",\n            queue: !1,\n            fn_index: i\n          }), z(\n            `${h}//${w + d.path}/run${r.startsWith(\"/\") ? r : `/${r}`}`,\n            {\n              ...u,\n              session_hash: N\n            }\n          ).then(([_, g]) => {\n            g == 200 ? (p({\n              type: \"status\",\n              endpoint: r,\n              fn_index: i,\n              status: \"complete\",\n              eta: _.average_duration,\n              queue: !1\n            }), p({\n              type: \"data\",\n              endpoint: r,\n              fn_index: i,\n              data: _.data\n            })) : p({\n              type: \"status\",\n              status: \"error\",\n              endpoint: r,\n              fn_index: i,\n              message: _.error,\n              queue: !1\n            });\n          }).catch((_) => {\n            throw p({\n              type: \"status\",\n              status: \"error\",\n              message: _.message,\n              endpoint: r,\n              fn_index: i,\n              queue: !1\n            }), new Error(_.message);\n          });\n        else {\n          p({\n            type: \"status\",\n            status: \"pending\",\n            queue: !0,\n            endpoint: r,\n            fn_index: i\n          });\n          const _ = `${f}://${w + d.path}/queue/join`, g = new WebSocket(_);\n          C.set(i, g), g.onclose = (E) => {\n            E.wasClean || p({\n              type: \"status\",\n              status: \"error\",\n              message: D,\n              queue: !0,\n              endpoint: r,\n              fn_index: i\n            });\n          }, g.onmessage = function(E) {\n            const k = JSON.parse(E.data), { type: m, status: l, data: b } = H(\n              k,\n              P[i]\n            );\n            if (m === \"update\" && l)\n              p({ type: \"status\", endpoint: r, fn_index: i, ...l }), l.status === \"error\" && (g.close(), a(l));\n            else if (m === \"hash\") {\n              g.send(JSON.stringify({ fn_index: i, session_hash: N }));\n              return;\n            } else\n              m === \"data\" ? g.send(JSON.stringify({ ...u, session_hash: N })) : m === \"complete\" ? (p({\n                type: \"status\",\n                ...l,\n                status: l == null ? void 0 : l.status,\n                queue: !0,\n                endpoint: r,\n                fn_index: i\n              }), g.close()) : m === \"generating\" && p({\n                type: \"status\",\n                ...l,\n                status: l == null ? void 0 : l.status,\n                queue: !0,\n                endpoint: r,\n                fn_index: i\n              });\n            b && (p({\n              type: \"data\",\n              data: b.data,\n              endpoint: r,\n              fn_index: i\n            }), c({ data: b.data }));\n          };\n        }\n      });\n    }\n    function R(r, u) {\n      return x(r, u);\n    }\n  });\n}\nfunction K(e, t) {\n  var s, n, o, f;\n  return !(((n = (s = t == null ? void 0 : t.dependencies) == null ? void 0 : s[e]) == null ? void 0 : n.queue) === null ? t.enable_queue : (f = (o = t == null ? void 0 : t.dependencies) == null ? void 0 : o[e]) != null && f.queue) || !1;\n}\nasync function U(e) {\n  if (typeof window < \"u\" && window.gradio_config && location.origin !== \"http://localhost:9876\") {\n    const t = window.gradio_config.root, s = window.gradio_config;\n    return s.root = e + s.root, { ...s, path: t };\n  } else if (e) {\n    let t = await fetch(`${e}/config`);\n    if (t.status === 200) {\n      const s = await t.json();\n      return s.path = s.path ?? \"\", s.root = e, s;\n    } else\n      throw new Error(\"Could not get config.\");\n  }\n  throw new Error(\"No config or app endpoint found\");\n}\nasync function $(e, t, s) {\n  let n = t === \"subdomain\" ? `https://huggingface.co/api/spaces/by-subdomain/${e}` : `https://huggingface.co/api/spaces/${e}`, o, f;\n  try {\n    if (o = await fetch(n), f = o.status, f !== 200)\n      throw new Error();\n    o = await o.json();\n  } catch {\n    s({\n      status: \"error\",\n      load_status: \"error\",\n      message: \"Could not get space status\",\n      detail: \"NOT_FOUND\"\n    });\n    return;\n  }\n  if (!o || f !== 200)\n    return;\n  const {\n    runtime: { stage: h },\n    id: w\n  } = o;\n  switch (h) {\n    case \"STOPPED\":\n    case \"SLEEPING\":\n      s({\n        status: \"sleeping\",\n        load_status: \"pending\",\n        message: \"Space is asleep. Waking it up...\",\n        detail: h\n      }), setTimeout(() => {\n        $(e, t, s);\n      }, 1e3);\n      break;\n    case \"RUNNING\":\n    case \"RUNNING_BUILDING\":\n      s({\n        status: \"running\",\n        load_status: \"complete\",\n        message: \"\",\n        detail: h\n      });\n      break;\n    case \"BUILDING\":\n      s({\n        status: \"building\",\n        load_status: \"pending\",\n        message: \"Space is building...\",\n        detail: h\n      }), setTimeout(() => {\n        $(e, t, s);\n      }, 1e3);\n      break;\n    default:\n      s({\n        status: \"space_error\",\n        load_status: \"error\",\n        message: \"This space is experiencing an issue.\",\n        detail: h,\n        discussions_enabled: await B(w)\n      });\n      break;\n  }\n}\nfunction H(e, t) {\n  switch (e.msg) {\n    case \"send_data\":\n      return { type: \"data\" };\n    case \"send_hash\":\n      return { type: \"hash\" };\n    case \"queue_full\":\n      return {\n        type: \"update\",\n        status: {\n          queue: !0,\n          message: J,\n          status: \"error\"\n        }\n      };\n    case \"estimation\":\n      return {\n        type: \"update\",\n        status: {\n          queue: !0,\n          status: t || \"pending\",\n          size: e.queue_size,\n          position: e.rank,\n          eta: e.rank_eta\n        }\n      };\n    case \"progress\":\n      return {\n        type: \"update\",\n        status: {\n          queue: !0,\n          status: \"pending\",\n          progress: e.progress_data\n        }\n      };\n    case \"process_generating\":\n      return {\n        type: \"generating\",\n        status: {\n          queue: !0,\n          message: e.success ? null : e.output.error,\n          status: e.success ? \"generating\" : \"error\",\n          progress: e.progress_data,\n          eta: e.average_duration\n        },\n        data: e.success ? e.output : null\n      };\n    case \"process_completed\":\n      return {\n        type: \"complete\",\n        status: {\n          queue: !0,\n          message: e.success ? void 0 : e.output.error,\n          status: e.success ? \"complete\" : \"error\",\n          progress: e.progress_data,\n          eta: e.output.average_duration\n        },\n        data: e.success ? e.output : null\n      };\n    case \"process_starts\":\n      return {\n        type: \"update\",\n        status: {\n          queue: !0,\n          status: \"pending\",\n          size: e.rank,\n          position: 0\n        }\n      };\n  }\n  return { type: \"none\", status: { status: \"error\", queue: !0 } };\n}\nexport {\n  V as client,\n  z as post_data,\n  Q as upload_files\n};\n"],"names":["D","Q","e","s","f","n"],"mappings":"AA+DK,MAAmDA,EAAI,0BAa5D,eAAeC,EAAEC,EAAG,EAAG,CACrB,MAAMC,EAAI,IAAI,SACd,EAAE,QAASC,GAAM,CACfD,EAAE,OAAO,QAASC,CAAC,CACvB,CAAG,EACD,GAAI,CACF,IAAIC,EAAI,MAAM,MAAM,GAAGH,WAAY,CACjC,OAAQ,OACR,KAAMC,CACZ,CAAK,CACL,MAAI,CACA,MAAO,CAAE,MAAOH,EACjB,CACD,MAAO,CAAE,MAAO,MAAMK,EAAE,KAAM,CAAA,CAChC"}